<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100%; }
		</style>
	</head>
	<body>
		<!-- <div id="fpsmeter"></div> -->

		<script src="node_modules/three/three.min.js"></script>
		<script src="node_modules/cannon/build/cannon.min.js"></script>
		<script src="fps.js"></script>

		<script>

		var Game = function () {
			this.utils = {
				timestamp : function timestamp () {
					return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
				}
			};

			var that        = this,
				dt          = 0,
				step        = 1/60,
				last        = this.utils.timestamp(),
				fpsmeter    = new FPSMeter(document.getElementById('fpsmeter'), { decimals: 0, graph: true, theme: 'dark', left: '5px' }),
				objects     = {
					cubes   : [],
					paddles : []
				},
				pressedKeys = [];



			var scene,
				camera,
				renderer,
				spotlight;

			scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 0, 500);

			camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.translateX(0);
			camera.translateY(5);
			camera.translateZ(20);

			renderer = new THREE.WebGLRenderer();
			renderer.shadowMapType = THREE.PCFSoftShadowMap;
            renderer.shadowMapEnabled = true;
            renderer.shadowMapSoft = true;
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor( scene.fog.color, 1 );

			spotlight = new THREE.SpotLight(0xffffff);
			spotlight.position.set(5 ,40, 15);
			spotlight.shadowMapWidth      = 1024;
			spotlight.shadowMapHeight     = 1024;
			spotlight.shadowCameraNear    = 10;
			spotlight.shadowCameraFov     = 50;
			spotlight.shadowCameraVisible = true;
			spotlight.shadowDarkness      = 0.95;
			spotlight.intensity           = 1.5;
			spotlight.castShadow          = true;
			scene.add(spotlight);



			var gameBoxGeometry,
				gameBoxMaterial,
				gameBox;

			gameBoxGeometry = new THREE.BoxGeometry(50, 50, 50);
			gameBoxMaterial = new THREE.MeshLambertMaterial({ color : 0x669999 , side : THREE.BackSide });
			gameBox 		= new THREE.Mesh(gameBoxGeometry, gameBoxMaterial);
			gameBox.receiveShadow = true;
			scene.add(gameBox);


			var ambientLight;
			ambientLight = new THREE.AmbientLight(0x222222);
			scene.add(ambientLight);


			var gameFieldGeometry,
				gameFieldMaterial,
				gameField;

			gameFieldGeometry = new THREE.PlaneGeometry(300, 300, 50, 50);
            gameFieldGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
            gameFieldMaterial = new THREE.MeshLambertMaterial({ color : 0xaaaaaa });
            gameField         = new THREE.Mesh(gameFieldGeometry, gameFieldMaterial);

            gameField.castShadow    = true;
            gameField.receiveShadow = true;
            scene.add(gameField);




			var world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            world.quatNormalizeSkip = 0;
            world.quatNormalizeFast = false;
			var solver = new CANNON.GSSolver();

            world.defaultContactMaterial.contactEquationStiffness = 1e9;
            world.defaultContactMaterial.contactEquationRelaxation = 4;

            solver.iterations = 7;
            solver.tolerance = 0.1;
            var split = true;
            if (split)
                world.solver = new CANNON.SplitSolver(solver);
            else
                world.solver = solver;

            world.broadphase = new CANNON.NaiveBroadphase();

            // Create a slippery material (friction coefficient = 0.0)
            physicsMaterial = new CANNON.Material("slipperyMaterial");

            var groundMaterial = new CANNON.Material();
            /*var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                    mat,
                                                                    {
                                                                    	friction : 0.0,
                                                                    	restitution : 0.9  // restitution
                                                                    }
                                                                    );
            // We must add the contact materials to the world
            world.addContactMaterial(physicsContactMaterial);*/

            // Create a plane
            var groundShape = new CANNON.Plane();
            var groundBody = new CANNON.Body({ mass : 0 , material : groundMaterial });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
            world.add(groundBody);



			var halfExtents       = new CANNON.Vec3(0.5, 0.5, 0.5);
		    var boxShape          = new CANNON.Box(halfExtents);
    		var boxCannonMaterial = new CANNON.Material();
		    
			var boxCannonMaterial_ground = new CANNON.ContactMaterial(groundMaterial, boxCannonMaterial, { friction: 1, restitution: 0.9 });
            world.addContactMaterial(boxCannonMaterial_ground);

            var boxMaterial = new THREE.MeshLambertMaterial({ color : 0xdddddd });
		    var boxGeometry = new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2);
		    for (var i = 0; i < 19; i++) {
		        var x = 0;
		        var y = i * 3;
		        var z = 0;

		        var boxBody = new CANNON.Body({ mass: 3, material : boxCannonMaterial });
		        /*boxBody.velocity.set(2, -10, 0);*/
		        boxBody.addShape(boxShape);
/*		        boxBody.torque = new CANNON.Vec3((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
*/		        var boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
		        world.add(boxBody);
		        scene.add(boxMesh);
		        boxBody.position.set(x, y, z);
		        boxMesh.position.set(x, y, z);
		        boxMesh.castShadow    = true;
		        boxMesh.receiveShadow = true;
		        objects.cubes.push({
		        	body : boxBody,
		        	mesh : boxMesh
		        });
		    }
			


			this.handleKeyUp = function (event) {
				pressedKeys[event.keyCode] = false;
			};
			this.handleKeyDown = function (event) {
				pressedKeys[event.keyCode] = true;
			};
			this.handleKeys = function () {
				if (pressedKeys[33]) {
					// Page Up
					z -= 0.05;
				}
				if (pressedKeys[34]) {
					// Page Down
					z += 0.05;
				}
				if (pressedKeys[37]) {
					// Left cursor key
					objects.cubes[0].position.x += -0.4;
				}
				if (pressedKeys[39]) {
					// Right cursor key
					objects.cubes[0].position.x -= -0.4;
				}
				if (pressedKeys[38]) {
					// Up cursor key
					objects.cubes[0].position.z += -0.4;
				}
				if (pressedKeys[40]) {
					// Down cursor key
					objects.cubes[0].position.z -= -0.4;
				}
			};

			this.update = function (step) {
				world.step(step);

				that.handleKeys();

				// Update box positions
                for(var i = 0; i < objects.cubes.length; i++) {
                    objects.cubes[i].mesh.position.copy(objects.cubes[i].body.position);
                    objects.cubes[i].mesh.quaternion.copy(objects.cubes[i].body.quaternion);
                }
			};

			this.render = function () {
				renderer.render(scene, camera);
			};

			this.frame = function () {
				fpsmeter.tickStart();
				now  = that.utils.timestamp();
				dt   = dt + Math.min(1, (now - last) / 1000);
				while (dt > step) {
					dt = dt - step;
					that.update(step);
					fpsmeter.tick();
				}
				that.render(dt);
				last = now;
				requestAnimationFrame(that.frame);
			};

			this.init = function () {
				renderer.setSize(window.innerWidth, window.innerHeight);

				document.body.appendChild(renderer.domElement);
				document.onkeyup   = this.handleKeyUp;
				document.onkeydown = this.handleKeyDown;

				for (var i = objects.cubes.length - 1; i >= 0; i--) {
					scene.add(objects.cubes[i].mesh);
				}
				
				this.frame();
			};
		};

		var game = new Game();
		game.init();

		</script>
	</body>
</html>