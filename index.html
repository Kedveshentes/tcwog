<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100%; }
		</style>
	</head>
	<body>
		<!-- <div id="fpsmeter"></div> -->

		<script src="node_modules/underscore/underscore-min.js"></script>
		<script src="node_modules/three/three.min.js"></script>
		<script src="node_modules/cannon/build/cannon.min.js"></script>
		<script src="fps.js"></script>

		<script>

		var Game = function () {
			this.utils = {
				timestamp : function timestamp () {
					return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
				},
				springs   : {
					stiffness : 1000,
					damping   : 30
				}
			};

			var that        = this,
				dt          = 0,
				step        = 1/60,
				last        = this.utils.timestamp(),
				fpsmeter    = new FPSMeter(document.getElementById('fpsmeter'), { decimals: 0, graph: true, theme: 'dark', left: '5px' }),
				objects     = {
					cubes   : [],
					lines   : [],
					springs : []
				},
				pressedKeys = [],
				mouse       = new THREE.Vector2();


			var scene,
				camera,
				renderer,
				spotlight;

			var raycaster,
				mouseIndicator,
				mouseIndicatorEnabled,
				distances,
				nearestBoxes,
				distancesMinIndex1,
				distancesMinIndex2,
				distancesMin1,
				distancesMin2;

			var gameBoxGeometry,
				gameBoxMaterial,
				gameBox;

			var gameFieldGeometry,
				gameFieldMaterial,
				gameField;

			var gameFieldRearGeometry,
				gameFieldRearMaterial,
				gameFieldRear;

			var world,
				solver,
				split;

			var springs;

			var groundMaterial,
				groundShape,
				groundBody;

			var planeMaterial,
				planeShape,
				planeRear,
				planeFront;

			var boxShape,
				boxCannonMaterial;


			this.initGameField = function () {
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(0x000000, 0, 500);

				camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
				camera.translateX(0);
				camera.translateY(10);
				camera.translateZ(25);

				renderer = new THREE.WebGLRenderer();
				renderer.shadowMapType = THREE.PCFSoftShadowMap;
				renderer.shadowMapEnabled = true;
				renderer.shadowMapSoft = true;
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor( scene.fog.color, 1 );


				/*gameBoxGeometry = new THREE.BoxGeometry(50, 50, 50);
				gameBoxMaterial = new THREE.MeshLambertMaterial({ color : 0x669999 , side : THREE.BackSide });
				gameBox         = new THREE.Mesh(gameBoxGeometry, gameBoxMaterial);
				gameBox.receiveShadow = true;
				scene.add(gameBox);*/


				gameFieldGeometry = new THREE.PlaneGeometry(30, 10, 50, 50);
				gameFieldGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
				gameFieldMaterial = new THREE.MeshLambertMaterial({ color : 0xaaaaaa });
				gameField         = new THREE.Mesh(gameFieldGeometry, gameFieldMaterial);

				gameField.position.z    = 5;
				gameField.castShadow    = true;
				gameField.receiveShadow = true;
				scene.add(gameField);


				gameFieldRearGeometry = new THREE.PlaneGeometry(30, 20, 50, 50);
				gameFieldRearMaterial = new THREE.MeshLambertMaterial({ color : 0xccccff });
				gameFieldRear         = new THREE.Mesh(gameFieldRearGeometry, gameFieldRearMaterial);

				gameFieldRear.position.y    = 10;
				gameFieldRear.castShadow    = true;
				gameFieldRear.receiveShadow = true;
				scene.add(gameFieldRear);


				var ambientLight;
				ambientLight = new THREE.AmbientLight(0x222222);
				scene.add(ambientLight);


				spotlight = new THREE.SpotLight(0xffffff);
				spotlight.position.set(5, 40, 15);
				spotlight.shadowMapWidth      = 1024;
				spotlight.shadowMapHeight     = 1024;
				spotlight.shadowCameraNear    = 10;
				spotlight.shadowCameraFov     = 50;
				spotlight.shadowCameraVisible = true;
				spotlight.shadowDarkness      = 0.95;
				spotlight.intensity           = 1.5;
				spotlight.castShadow          = true;
				scene.add(spotlight);


				solver = new CANNON.GSSolver();
				world  = new CANNON.World();
				world.gravity.set(0, -20, 0);
				world.quatNormalizeSkip = 0;
				world.quatNormalizeFast = false;

				world.defaultContactMaterial.contactEquationStiffness = 1e9;
				world.defaultContactMaterial.contactEquationRelaxation = 4;

				solver.iterations = 7;
				solver.tolerance = 0.1;
				split = true;
				if (split) {
					world.solver = new CANNON.SplitSolver(solver);
				}
				else {
					world.solver = solver;
				}

				world.broadphase = new CANNON.NaiveBroadphase();

				groundMaterial = new CANNON.Material();

				groundShape    = new CANNON.Plane();
				groundBody     = new CANNON.Body({ mass : 0 , material : groundMaterial });
				groundBody.addShape(groundShape);
				groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), - Math.PI / 2);
				world.add(groundBody);


				planeMaterial = new CANNON.Material();
				planeShape    = new CANNON.Plane();

				planeRear     = new CANNON.Body({ mass: 0 , material : planeMaterial });
				planeRear.addShape(planeShape);
				planeRear.position.set(0, 0, -0.5);
				world.add(planeRear);

				planeFront    = new CANNON.Body({ mass: 0 , material : planeMaterial });
				planeFront.addShape(planeShape);
				planeFront.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), - Math.PI);
				planeFront.position.set(0, 0, 0.55);
				world.add(planeFront);

				raycaster = new THREE.Raycaster();
			};


			this.initObjects = function () {
				var mouseIndicatorMaterial = new THREE.MeshLambertMaterial({ color : 0xffdddd }),
					mouseIndicatorGeometry = new THREE.BoxGeometry(1, 1, 1);
				mouseIndicator             = new THREE.Mesh(mouseIndicatorGeometry, mouseIndicatorMaterial);

				distances    = [];
				nearestBoxes = [];

				mouseIndicator.visible = false;
				scene.add(mouseIndicator);


				var halfExtents = new CANNON.Vec3(0.5, 0.5, 0.5);

				boxShape          = new CANNON.Box(halfExtents);
				boxCannonMaterial = new CANNON.Material();
				
				var boxCannonMaterial_ground = new CANNON.ContactMaterial(groundMaterial, boxCannonMaterial, { friction: 1, restitution: 0 });
				world.addContactMaterial(boxCannonMaterial_ground);
				
				var boxCannonMaterial_boxCannonMaterial = new CANNON.ContactMaterial(boxCannonMaterial, boxCannonMaterial, { friction: 0.9, restitution: 0.5 });
				world.addContactMaterial(boxCannonMaterial_boxCannonMaterial);
				
				var boxCannonMaterial_planeMaterial = new CANNON.ContactMaterial(boxCannonMaterial, planeMaterial, { friction: 0, restitution: 0 });
				world.addContactMaterial(boxCannonMaterial_planeMaterial);

				var boxGeometry = new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2);

				for (var i = 0; i < 3; i++) {
					var x = 0;
					var y = i * 3;
					var z = 0;

					var boxMaterial = new THREE.MeshLambertMaterial({ color : 0x99ffff });
					var boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
					var boxBody = new CANNON.Body({ mass : 3, material : boxCannonMaterial });
					boxBody.addShape(boxShape);
					world.add(boxBody);
					scene.add(boxMesh);
					boxBody.position.set(x, y, z);
					boxMesh.position.set(x, y, z);
					boxMesh.castShadow    = true;
					boxMesh.receiveShadow = true;
					objects.cubes.push({
						body : boxBody,
						mesh : boxMesh
					});
				}

				objects.springs.push(
					new CANNON.Spring(objects.cubes[0].body, objects.cubes[1].body, {
						localAnchorA : new CANNON.Vec3(0, 0, 0),
						localAnchorB : new CANNON.Vec3(0, 0, 0),
						restLength   : 5,
						stiffness    : this.utils.springs.stiffness,
						damping      : this.utils.springs.damping
					})
				);
				objects.springs.push(
					new CANNON.Spring(objects.cubes[1].body, objects.cubes[2].body, {
						localAnchorA : new CANNON.Vec3(0, 0, 0),
						localAnchorB : new CANNON.Vec3(0, 0, 0),
						restLength   : 5,
						stiffness    : this.utils.springs.stiffness,
						damping      : this.utils.springs.damping
					})
				);
				objects.springs.push(
					new CANNON.Spring(objects.cubes[2].body, objects.cubes[0].body, {
						localAnchorA : new CANNON.Vec3(0, 0, 0),
						localAnchorB : new CANNON.Vec3(0, 0, 0),
						restLength   : 5,
						stiffness    : this.utils.springs.stiffness,
						damping      : this.utils.springs.damping
					})
				);
			};


			this.handleKeyUp = function (event) {
				pressedKeys[event.keyCode] = false;
			};
			this.handleKeyDown = function (event) {
				pressedKeys[event.keyCode] = true;
			};
			this.handleKeys = function () {
				if (pressedKeys[33]) {
					// Page Up
					z -= 0.05;
				}
				if (pressedKeys[34]) {
					// Page Down
					z += 0.05;
				}
				if (pressedKeys[37]) {
					// Left cursor key
					objects.cubes[0].position.x += -0.4;
				}
				if (pressedKeys[39]) {
					// Right cursor key
					objects.cubes[0].position.x -= -0.4;
				}
				if (pressedKeys[38]) {
					// Up cursor key
					objects.cubes[0].position.z += -0.4;
				}
				if (pressedKeys[40]) {
					// Down cursor key
					objects.cubes[0].position.z -= -0.4;
				}
			};
			this.handleMouseMove = function (event) {
				event.preventDefault();
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
			};
			this.handleMouseClick = function (event) {
				if (mouseIndicatorEnabled) {
					var boxMaterial    = new THREE.MeshLambertMaterial({ color : 0xdddddd }),
						newBoxGeometry = new THREE.BoxGeometry(1, 1, 1),
						newBoxMesh     = new THREE.Mesh(newBoxGeometry, boxMaterial),
						newBoxBody     = new CANNON.Body({ mass : 3, material : boxCannonMaterial });

					newBoxBody.addShape(boxShape);
					world.add(newBoxBody);
					scene.add(newBoxMesh);
					newBoxBody.position.set(mouseIndicator.position.x, mouseIndicator.position.y, mouseIndicator.position.z);
					newBoxMesh.position.set(mouseIndicator.position.x, mouseIndicator.position.y, mouseIndicator.position.z);
					newBoxMesh.castShadow    = true;
					newBoxMesh.receiveShadow = true;
					objects.cubes.push({
						body : newBoxBody,
						mesh : newBoxMesh
					});


					objects.springs.push(
						new CANNON.Spring(objects.cubes[distancesMinIndex1].body, objects.cubes[objects.cubes.length - 1].body, {
							localAnchorA : new CANNON.Vec3(0, 0, 0),
							localAnchorB : new CANNON.Vec3(0, 0, 0),
							restLength   : distancesMin1,
							stiffness    : that.utils.springs.stiffness,
							damping      : that.utils.springs.damping
						})
					);
					objects.springs.push(
						new CANNON.Spring(objects.cubes[distancesMinIndex2].body, objects.cubes[objects.cubes.length - 1].body, {
							localAnchorA : new CANNON.Vec3(0, 0, 0),
							localAnchorB : new CANNON.Vec3(0, 0, 0),
							restLength   : distancesMin2,
							stiffness    : that.utils.springs.stiffness,
							damping      : that.utils.springs.damping
						})
					);

					var material,
						geometry,
						line;

					material = new THREE.LineBasicMaterial({
						color : 0x66ffff
					});
					geometry = new THREE.Geometry();
					geometry.vertices.push(objects.cubes[distancesMinIndex1].mesh.position);
					geometry.vertices.push(objects.cubes[objects.cubes.length - 1].mesh.position);
					line = new THREE.Line(geometry, material);

					objects.lines.push({
						material  : material,
						geometry  : geometry,
						mesh      : line,
						box1      : distancesMinIndex1,
						box2      : objects.cubes.length - 1
					});
					scene.add(line);

					material = new THREE.LineBasicMaterial({
						color : 0x66ffff
					});
					geometry = new THREE.Geometry();
					geometry.vertices.push(objects.cubes[distancesMinIndex2].mesh.position);
					geometry.vertices.push(objects.cubes[objects.cubes.length - 1].mesh.position);
					line = new THREE.Line(geometry, material);

					objects.lines.push({
						material  : material,
						geometry  : geometry,
						mesh      : line,
						box1      : distancesMinIndex1,
						box2      : objects.cubes.length - 1
					});
					scene.add(line);
				}
			};


			this.update = function (step) {
				world.step(step);

				_.each(objects.springs, function (spring) {
					spring.applyForce();
				});

				that.handleKeys();

				var objectsToCheck = [];
				objectsToCheck.push(gameFieldRear);

/*  LOOKING FOR THE 2 NEAREST BOXES  */
				for (var i = 0; i < objects.cubes.length; i++) {
					var dx = objects.cubes[i].mesh.position.x - mouseIndicator.position.x,
						dy = objects.cubes[i].mesh.position.y - mouseIndicator.position.y,
						dz = objects.cubes[i].mesh.position.z - mouseIndicator.position.z;

					distances.push(Math.sqrt(dx * dx + dy * dy + dz * dz));
					objects.cubes[i].mesh.material.transparent = false;
				}

				distancesMin1      = _.min(distances);
				distancesMinIndex1 = _.indexOf(distances, distancesMin1);

				objects.cubes[distancesMinIndex1].mesh.material.transparent = true;
				objects.cubes[distancesMinIndex1].mesh.material.opacity = 0.5;

				distances[distancesMinIndex1] = Infinity;

				distancesMin2      = _.min(distances);
				distancesMinIndex2 = _.indexOf(distances, distancesMin2);

				objects.cubes[distancesMinIndex2].mesh.material.transparent = true;
				objects.cubes[distancesMinIndex2].mesh.material.opacity = 0.3;

				distances = [];
/* / LOOKING FOR THE 2 NEAREST BOXES */

/*  REFRESH LINES ACCORDING TO THEIR ENDPOINT BOXES  */
				for (var i = 0; i < objects.lines.length; i++) {
					objects.lines[i].mesh.geometry.vertices[0].set(objects.cubes[objects.lines[i].box1].mesh.position);
					objects.lines[i].mesh.geometry.vertices[1].set(objects.cubes[objects.lines[i].box2].mesh.position);
					objects.lines[i].mesh.geometry.verticesNeedUpdate = true;
				}
/* / REFRESH LINES ACCORDING TO THEIR ENDPOINT BOXES */



				raycaster.setFromCamera(mouse, camera);
				var intersection = raycaster.intersectObjects(objectsToCheck);

				if (intersection.length) {
					mouseIndicatorEnabled = true;
					mouseIndicator.position.set(intersection[0].point.x, intersection[0].point.y, intersection[0].point.z);
				} else {
					mouseIndicatorEnabled = false;
				}

				if (mouseIndicatorEnabled) {
					mouseIndicator.visible = true;
				} else {
					mouseIndicator.visible = false;
				}

				// Update box positions
				for (var i = 0; i < objects.cubes.length; i++) {
					objects.cubes[i].mesh.position.copy(objects.cubes[i].body.position);
					objects.cubes[i].mesh.quaternion.copy(objects.cubes[i].body.quaternion);
				}
			};

			this.render = function () {
				renderer.render(scene, camera);
			};

			this.frame = function () {
				fpsmeter.tickStart();
				now  = that.utils.timestamp();
				dt   = dt + Math.min(1, (now - last) / 1000);
				while (dt > step) {
					dt = dt - step;
					that.update(step);
					fpsmeter.tick();
				}
				that.render(dt);
				last = now;
				requestAnimationFrame(that.frame);
			};

			this.init = function () {
				this.initGameField();
				this.initObjects();

				raycaster = new THREE.Raycaster();

				renderer.setSize(window.innerWidth, window.innerHeight);

				document.body.appendChild(renderer.domElement);
				document.onkeyup     = this.handleKeyUp;
				document.onkeydown   = this.handleKeyDown;
				document.onmousemove = this.handleMouseMove;
				document.onclick     = this.handleMouseClick;
				console.log(document);

				for (var i = objects.cubes.length - 1; i >= 0; i--) {
					scene.add(objects.cubes[i].mesh);
				}
				
				this.frame();
			};
		};

		var game = new Game();
		game.init();

		</script>
	</body>
</html>